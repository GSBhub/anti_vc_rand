# Anti-Windows Rand
Example script for reversing a Windows seed given enough random values from the rand() function in vc++.

# Usage
`anti_rand.py -r [LIST_OF_RANDOM_ITEMS] -n NUMBER_OF_SAMPLES_GENERATED`
The list of random items needs to be those generated by the windows `rand` function, delimited by a space. The `NUMBER_OF_SAMPLES_GENERATED` is the estimated number of times rand() was called since it was seeded.

There's also a python implementation of the `rand` function from windows (uses the same constants) in the `lib` folder. It can be called with `lib/windows_rand.py -n NUMBER_OF_SAMPLES_GENERATED -s SEED`. If no seed is provided, a random one is generated. If no number of samples is provided, the default is 1.

## Theory
`rand` in VC++ uses a Linear Congruential Generator with the constants `a=214013`, `c=2531011`, and `m=2^32` to generate random numbers. LCG basically goes `x = (a * x + c) % m`, where the first `x` value is the `seed` for the RNG, and every subsequent value is the previous output of `rand`. 


In a standard LCG, the modulus operation can be undone using the Extended Euclidian Algorithm, which allows you to "replay" the LCG function backwards if given a specific random value. VC++'s `rand` is a bit different, in that it only returns some of the bytes output by `rand`. Windows `rand` shifts the output of the previous LCG right by 16 bits, then ands it with the constant `0x7FFF` (hence the `RAND_MAX` value being 0x7FFF in Windows)


## Reversing the "seed" given some random samples
If given enough (generally 3 or more) random samples, and some knowledge of how many previous random samples were generated with a seed, one can attempt to "brute force" the seed.

The algorithm works like this:
    1. For the last given random value, shift the `rand` value left by 16 bits. (ex, `rand()` gives `0xDEAD` -> expanded rand of `0xDEAD0000`

    2. For all values in 0, 0x1FFFF, add it to the base expanded rand and use it to generate an anti-lcg.

    3. For all anti-lcg generators, generate the next LCG (so the previous full rand value in the chain). Run it through the Windows bit truncate process (>> 16 & 0x7FFF), compare to the next known random.

    4. If they are not equal, discard that generator. 

    5. If they are equal, save that generator as a "likely" candidate.

    6. Repeat 3 - 5 for the number of "guesses", that is, the number of random numbers generated with your target seed given your initial guess. You don't need every single random number generated between your starting sample and the final, you just need a few samples (ie, 3-5 of the last numbers generated in a 10000 number sequence can recover the entire sequence).

    Once you have iterated through all potential guesses, your next iteration for the remaining should be the "seed" value.

## Current bugs
Test cases may fail (generally due to the exact number of seed candidates not being super consistent -> though this will also return a seed that will likely be funcitonally identical to your sequence (for at least a while), which is another potentially interesting feature.
